/* A Bison parser, made from gram.y
  by GNU bison 1.35.  */

/*
 * ported from:
 * https://github.com/julius-speech/julius/blob/6d135a686a74376495a7a6f55d3d67df54186f83/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c
 * info:
 * http://www.isi.edu/~pedro/Teaching/CSCI565-Fall16/Materials/LexAndYaccTutorial.pdf
 * JS lexer: https://github.com/aaditmshah/lexer
 * JS alloc: https://github.com/codemix/malloc
 * 
 * Copyright (c) 1991-2013 Kawahara Lab., Kyoto University
 * Copyright (c) 2000-2005 Shikano Lab., Nara Institute of Science and Technology
 * Copyright (c) 2005-2013 Julius project team, Nagoya Institute of Technology
 * All rights reserved
 */
(function () {

  // A lexical scanner generated by flex

  // Scanner skeleton version:
  // $Header: /cvsroot/julius/julius4/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c,v 1.7 2013/06/20 17:14:18 sumomo Exp $

  // #include <stdio.h>
  // #include <errno.h>
  
  var FLEX_SCANNER;
  var BEGIN;
  var REJECT;
  var EOB_ACT_CONTINUE_SCAN;
  var EOB_ACT_END_OF_FILE;
  var EOB_ACT_LAST_MATCH;

  var YY_FLEX_MAJOR_VERSION = 2;
  var YY_FLEX_MINOR_VERSION = 5;
  var YY_ALWAYS_INTERACTIVE;
  var YY_USER_ACTION;
  var YY_NEVER_INTERACTIVE;
  var YY_PROTO;
  var YY_USE_PROTOS;
  var YY_USE_CONST;
  var YY_MALLOC_DECL;
  var YY_SKIP_YYWRAP;
  var YY_NULL;
  var YY_DECL;
  var ECHO;
  var YY_SC_TO_UI;
  var YY_BREAK;
  var YY_INPUT;
  var YY_NEW_FILE;
  var YY_START;
  var YY_USER_INIT;
  var YY_READ_BUF_SIZE;
  var YY_END_OF_BUFFER;
  var YY_STATE_EOF;
  var YY_END_OF_BUFFER_CHAR;
  var YY_BUF_SIZE;
  var YY_BUFFER_STATE;
  var YY_CURRENT_BUFFER;
  var YY_RESTORE_YY_MORE_OFFSET;
  var YY_MORE_ADJ;
  var YY_DO_BEFORE_ACTION;
  var YY_FLUSH_BUFFER;
  var YY_AT_BOL;
  var YY_CHAR;
  var YY_RULE_SETUP;
  var YY_NUM_RULES;
  var YY_NEED_STRLEN;
  var YY_NO_PUSH_STATE;
  var YY_NO_POP_STATE;
  var YY_NO_TOP_STATE;
  var YY_START_STACK_INCR;
  var YY_FATAL_ERROR;

  var yy_set_interactive;
  var yy_buffer_state;
  var yy_current_buffer;
  var yy_did_buffer_switch_on_eof;
  var yy_start;
  var yy_const;
  var yywrap;
  var yy_flex_strle;
  var yyrestart;
  var yyleng;
  var yyin;
  var yy_is_jam;
  var yy_match;
  var yyout;
  var getc;
  var stdin;
  var stdout;
  var yy_cp;
  var yy_act;
  var yy_hold_char;
  var yy_c_buf_p;
  var yy_bp;
  var yyunput;
  var yytext_ptr;
  var unput;
  var input;
  var yy_size_t;
  var yy_n_chars; 
  var yy_init;
  var yy_switch_to_buffer;
  var yy_load_buffer_state;
  var yy_create_buffer;
  var yy_init_buffer;
  var yy_flush_buffer;
  var yy_delete_buffer;
  var yy_scan_buffer;
  var yy_scan_string;
  var yy_scan_bytes;
  var new_state;
  var yy_flex_alloc;
  var yy_flex_realloc;
  var yy_flex_free;
  var yy_new_buffer;
  var yy_top_state;
  var yy_pop_state;
  var yy_push_state;
  var yy_start_stack_ptr;
  var yy_start_stack_depth;
  var yy_start_stack;
  var yy_set_bol;
  var yy_state_type;
  var yytext;
  var yy_flex_strncpy;
  var yy_try_NUL_trans;
  var yy_get_next_buffer;
  var yy_fatal_error;
  var msg;
  var frwrite;
  var buf_ptr;
  var yy_accept;
  var yy_ec;
  var yy_meta;
  var yy_base;
  var yy_def;
  var yy_nxt;
  var yy_last_accepting_state;
  var yy_last_accepting_cpos;
  var yymore;
  var yymore_used_but_not_detected;
  var errno;
  var buf;
  var EOF;
  var EINTR;
  var clearerr;
  var fread;
  var ferror;
  var yyterminate;

  var file;
  var size;

  // cfront 1.2 defines "c_plusplus" instead of "__cplusplus"
  var c_plusplus;
  var __cplusplus;
  var _WIN32;
  var __STDC__;
  var __TURBOC__;

  if (c_plusplus) {
    if (__cplusplus === undefined) {
      __cplusplus;
    }
  }
  if (__cplusplus) {
    // #include <stdlib.h>
    if (_WIN32 === undefined) {
      // #include <unistd.h>
    } else {
      if (YY_ALWAYS_INTERACTIVE === undefined) {
        if (YY_NEVER_INTERACTIVE === undefined) {
          // extern int isatty YY_PROTO(( int ));
          // XXX integer, which returns 1 if file descriptor refers to terminal?
          // http://stackoverflow.com/questions/36258224/what-is-isatty-in-c-for
          YY_PROTO();
        }
      }
    }

    // Use prototypes in function declarations.
    YY_USE_PROTOS = 1;
  
    // The "const" storage-class-modifier is valid.
    YY_USE_CONST = 1;
  } else {
    if (__STDC__) {
      YY_USE_PROTOS = 1;
      YY_USE_CONST = 1;  
    }    
  }
  
  if (__TURBOC__) {
    // #pragma warn -rch
    // #pragma warn -use
    // #include <io.h>
    // #include <stdlib.h>
    YY_USE_PROTOS = 1;
    YY_USE_CONST = 1;
  }
  
  if (YY_USE_CONST) {
    yyconst;
  } else {
    yyconst;
  }

  // XXX just skip proto
  //if (YY_USE_PROTOS) {
  //  // XXX YY_PROTO(proto) proto
  //  YY_PROTO = function (proto) {
  //    return proto;
  //  };
  //} else {
  //  // XXX YY_PROTO(proto) ()
    YY_PROTO = function (proto) {
      return proto;
    };
  //}

  yywrap = function () {
    return 1;
  };
  
  // Returned upon end-of-file.
  YY_NULL = 0;
  
  // Promotes a possibly negative, possibly signed char to an unsigned
  // integer for use as an array index.  If the signed char is negative,
  // we want to instead treat it as an 8-bit unsigned char, hence the
  // double cast.
  // #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
  YY_SC_TO_UI = function (c) {
    return c;
  };
  
  // Enter a start condition.  This macro really ought to take a parameter,
  // but we do it the disgusting crufty way forced on us by the ()-less
  // definition of BEGIN.
  // XXX #define BEGIN yy_start = 1 + 2 *
  BEGIN = function () {
    yy_start = 1 + 2;
  };
  
  // Translate the current start state into a value that can be later handed
  // to BEGIN to return to the state.  The YYSTATE alias is for lex
  // compatibility.
  YYSTATE = YY_START;
  YY_START = (yy_start - 1)/2;
  
  // Action number for EOF rule of a given start state.
  YY_STATE_EOF = function (state) {
    return YY_END_OF_BUFFER + state + 1;
  };
  
  // Special action meaning "start processing a new file".
  YY_NEW_FILE = yyrestart(yyin);
  YY_END_OF_BUFFER_CHAR = 0;
  
  // Size of default input buffer.
  YY_BUF_SIZE = 16384;
  
  // XXX typdef struct ?
  YY_BUFFER_STAGE = yy_buffer_state();

  // externals => http://epaperpress.com/lexandyacc/prl.html
  yyleng;
  yyin;
  yyout;


  EOB_ACT_CONTINUE_SCAN = 0;
  EOB_ACT_END_OF_FILE = 1;
  EOB_ACT_LAST_MATCH = 2;

  // The funky do-while in the following #define is used to turn the definition
  // int a single C statement (which needs a semi-colon terminator).  This
  // avoids problems with code like:
  //
  //  if ( condition_holds )
  //    yyless( 5 );
  //  else
  //    do_something_else();
  //
  // Prior to using the do-while the compiler would get upset at the
  // "else" because it interpreted the "if" statement as being all
  // done when it reached the ';' after the yyless() call.
  
  // Return all but the first 'n' matched characters back to the input stream.
  yyless = function (n) {
    // do {
      // Undo effects of setting up yytext.
      yy_cp = yy_hold_char;
      YY_RESTORE_YY_MORE_OFFSET();
      yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ;
      YY_DO_BEFORE_ACTION(); // set up yytext again
    // } while (0)
  }

  unput = function (c) {
    yyunput(c, yytext_ptr);
  };

  // The following is because we cannot portably get our hands on size_t
  // (without autoconf's help, which isn't available because we want
  // flex-generated scanners to compile on their own).
  yy_size_t;

  yy_create_buffer = function (file, size) {
  //yy_buffer_state = function (file, size) {
    yy_current_buffer = {
      yy_input_file: file,
      
      // input buffer
      yy_ch_buf: null,
      
      // current position in input buffer
      yy_buf_pos: null,
      
      // Size of input buffer in bytes, not including room for EOB characters.
      yy_size_t: size, //yy_buf_size,
      
      // Number of characters read into yy_ch_buf, not including EOB characters.
      yy_n_chars: null,
      
      // Whether we "own" the buffer - i.e., we know we created it,
      // and can realloc() it to grow it, and should free() it to delete it.
      yy_is_our_buffer: null,
  
      // Whether this is an "interactive" input source; if so, and
      // if we're using stdio for input, then we want to use getc()
      // instead of fread(), to make sure we stop fetching input after 
      // each newline.
      yy_is_interactive: null,
  
      // Whether we're considered to be at the beginning of a line.
      // If so, '^' rules will be active on the next match, otherwise not.
      yy_at_bol: null,
  
      // Whether to try to fill the input buffer when we reach the end of it.
      yy_fill_buffer: null,
  
      yy_buffer_status: null,
  
      YY_BUFFER_NEW: 0,
      YY_BUFFER_NORMAL: 1,
    
      // When an EOF's been seen but there's still some text to process
      // then we mark the buffer as YY_EOF_PENDING, to indicate that we
      // shouldn't try reading from the input source any more.  We might
      // still have a bunch of tokens to match, though, because of
      // possible backing-up.
      //
      // When we actually see the EOF, we change the status to "new"
      // (via yyrestart()), so that the user can continue scanning by
      // just pointing yyin at a new input file.
      YY_BUFFER_EOF_PENDING: 2
    };
  };

  // XXX moved down
  //YY_BUFFER_STATE = function () {
  //  yy_current_buffer = 0;
  //};

  // We provide macros for accessing buffer states in case in the
  // future we want to put the buffer states in a more general
  // "scanner state".
  YY_CURRENT_BUFFER = function () {
    return yy_current_buffer;
  };

  //yy_hold_char holds the character lost when yytext is formed.
  yy_hold_char;
  
  // number of characters read into yy_ch_buf
  yy_n_chars;   

  // length of matched string
  yyleng;

  // Points to current character [position] in buffer.
  // (char *) 0; => Not a null character. Pointer to a character at address 0.
  yy_c_buf_p = 0;
  
  //whether we need to initialize
  yy_init = 1;
  
  // Start state number
  yy_start = 0;

  // Flag which is used to allow yywrap()'s to do buffer switches
  // instead of setting up a fresh yyin.  A bit of a hack ...
  yy_did_buffer_switch_on_eof;

  // XXX what does proto do? nothing
  yyrestart = function (input_file) {
    FILE = YY_PROTO(input_file);
  };

  yy_switch_to_buffer = function(new_buffer) {
    YY_BUFFER_STATE(YY_PROTO(new_buffer)); 
  };
  
  // XXX void yy_load_buffer_state YY_PROTO(( void ));  
  yy_load_buffer_state = function () {
    // XXX now what?
  };

  // XXX hm... create a new buffer?
  // XXX arrayBuffer here!
  YY_BUFFER_STATE = function (input_file) {
    yy_current_buffer = 0;
    yy_create_buffer(YY_PROTO(input_file), YY_PROTO(input_file.length));
  };

  yy_delete_buffer = function (b) {
    yy_current_buffer = YY_PROTO(0);    
  };
  
  // XXX load file into buffer?
  yy_init_buffer = function (b, file) {
    // load a file into the arraybuffer inside current_buffer
  };
  
  // XXX I imagine resetting the buffer to initial state?
  yy_flush_buffer = function (current_buffer) {
    // XXX => YY_PROTO(( YY_BUFFER_STATE b )
  };
  
  YY_FLUSH_BUFFER = function (current_buffer) {
    yy_flush_buffer(current_buffer);
  };
  
  // XXX does what?
  yy_scan_buffer = function (base, size) {
    // XXX? YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
  };
  
  // XXX find a string?
  yy_scan_string = function (yy_str) {
    // XXX? YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
  };

  // XXX scan ?
  yy_scan_bytes = function (bytes, len) {
    // XXX ?YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
  };

  yy_flex_alloc = function (yy_size_t) {
    // mhmh
  };
  
  yy_flex_realloc = function (yy_size_t) {
    // XXX *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
  };
  
  yy_flex_free = function () {
    // XXX free like a bird
  };

  yy_new_buffer = yy_create_buffer;
  
  yy_set_interactive = function (is_interactive) {
    if (!yy_current_buffer) {
      yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE);
      yy_current_buffer.yy_is_interactive = is_interactive;
    }
  };
  
  yy_set_bol = function(at_bol) {
    if (!yy_current_buffer) {
      yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE);
      yy_current_buffer.yy_at_bol = at_bol;
    }
  };

  YY_AT_BOL = function () {
    return yy_current_buffer.yy_at_bol;
  };
  
  YY_CHAR;
  yyin = []; // XXX input file FILE *yyin = (FILE *) 0
  yyout = []; // XXX *yyout = (FILE *) 0;
  yy_state_type; // int;
  yytext = [];
  yytext_ptr = 0;
  yy_state_type = yy_get_previous_state() || 0;
  // XXX hm...
  yy_state_type = yy_try_NUL_trans() || YY_PROTO(current_state);
  yy_get_next_buffer;
  yy_fatal_error = function (msg) {
    return msg;
  };

  // Done after the current pattern has been matched and before the
  // corresponding action - sets up yytext.
  YY_DO_BEFORE_ACTION = function () {
    yytext_ptr = yy_bp;
    yyleng = yy_cp - yy_bp;
    yy_hold_char = yy_cp; // pointer to
    yy_c_buf_p = yy_cp;
  };

  YY_NUM_RULES = 14;
  YY_END_OF_BUFFER = 15;

  yy_accept = [
      0,
      0,    0,   15,   13,   12,   10,    7,   13,   13,    8,
      2,    9,   13,    3,    4,    0,   11,    0,    0,    2,
      1,    0,    0,    0,    0,    0,    0,    0,    0,    5,
      6,    0
  ];
  
  yy_ec = [
    0,
    1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    2,    4,    1,    5,    1,    6,    1,    1,    1,
    1,    7,    1,    1,    1,    1,    1,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    9,    1,    1,
    1,    1,    1,   10,   11,    8,    8,    8,   12,    8,
   13,    8,   14,    8,    8,    8,    8,   15,   16,    8,
    8,   17,   18,    8,    8,    8,    8,    8,    8,    8,
    1,    1,    1,    1,    8,    1,    8,    8,    8,    8,

    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,   19,    1,   20,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1
  ];

  yy_meta = [
    0,
    1,    1,    1,    1,    1,    1,    1,    2,    1,    1,
    2,    2,    2,    2,    2,    2,    2,    2,    1,    1
  ];

  yy_base = [
    0,
    0,    0,   39,   40,   40,   40,   40,   35,   10,   40,
    0,   40,    0,   40,   40,   34,   40,   18,   22,    0,
    0,   16,   18,   18,   15,   17,   12,   13,   15,   40,
   40,   40,   24,   21,   20
  ];

  yy_def = [
     0,
     32,    1,   32,   32,   32,   32,   32,   33,   32,   32,
     34,   32,   35,   32,   32,   33,   32,   32,   32,   34,
     35,   32,   32,   32,   32,   32,   32,   32,   32,   32,
     32,    0,   32,   32,   32
  ];

  yy_nxt = [
    0,
    4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
   11,   11,   11,   11,   11,   11,   11,   11,   14,   15,
   18,   21,   20,   19,   16,   16,   31,   30,   29,   28,
   27,   26,   25,   24,   23,   22,   17,   17,   32,    3,
   32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
   32,   32,   32,   32,   32,   32,   32,   32,   32,   32
  ];

  yy_chk = [
    0,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    9,   35,   34,    9,   33,   33,   29,   28,   27,   26,
   25,   24,   23,   22,   19,   18,   16,    8,    3,   32,
   32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
   32,   32,   32,   32,   32,   32,   32,   32,   32,   32
  ];

  yy_state_type = yy_last_accepting_state;
  yy_last_accepting_cpos;

  // The intent behind this definition is that it'll catch
  // any uses of REJECT which flex missed.
  REJECT = function () {
    return reject_used_but_not_detected;
  };
  yymore = function () {
    return yymore_used_but_not_detected;
  };
  YY_MORE_ADJ = 0;
  YY_RESTORE_YY_MORE_OFFSET();
  yytext;
  // #line 1 "gram.l"
  INITIAL = 0;
  // #line 391 "lex.yy.c"

  // Macros after this point can all be overridden by user definitions in 
  // section 1.
  if (YY_SKIP_YYWRAP === undefined) {
    if (__cplusplus) {
      yywrap = YY_PROTO();
    } else {
      yywrap = YY_PROTO();
    }
  }

  if (YY_NO_UNPUT === undefined) {
    // XXX 2 params
    yyunput = YY_PROTO(c, buf_ptr);
  }

  if (yytext_ptr === undefined) {
    // static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
    yy_flex_strncpy = YY_PROTO(char, yyconst);
  }

  if (YY_NEED_STRLEN) {
    yy_flex_strlen = YY_PROTO(yyconst_char);
  }

  if (YY_NO_INPUT === undefined) {
    if (__cplusplus) {
      yy_input = YY_PROTO();
    } else {
      input = YY_PROTO();
    }
  }
  
  if (YY_STACK_USED) {
    yy_start_stack_ptr = 0;
    yy_start_stack_depth = 0;
    yy_start_stack = 0; // pointer
    if (YY_NO_PUSH_STATE === undefined) {
      yy_push_state = YY_PROTO(new_state);
    }
    if (YY_NO_POP_STATE === undefined) {
      yy_pop_state = YY_PROTO();
    }
    if (YY_NO_TOP_STATE === undefined) {
      yy_top_state = YY_PROTO();
    }
  } else {
    YY_NO_PUSH_STATE = 1;
    YY_NO_POP_STATE = 1;
    YY_NO_TOP_STATE = 1;
  }
  
  if (YY_MALLOC_DECL) {
    YY_MALLOC_DECL;
  } else {
    if (__STDC__) {
      if (__cplusplus === undefined) {
        // #include <stdlib.h> 
      }
    } else {
      // Just try to get by without declaring the routines.  This will fail
      // miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
      //* or sizeof(void*) != sizeof(int).
    }
  }

  // Amount of stuff to slurp up with each read.
  if (YY_READ_BUF_SIZE === undefined) {
    YY_READ_BUF_SIZE = 8192;
  }

  // Copy whatever the last rule matched to the standard output.
  if (ECHO === undefined) {
    // This used to be an fputs(), but since the string might contain NUL's,
    // we now use fwrite().
    // write from array to stream
    //ECHO = fwrite(yytext, yyleng, 1, yyout);
    ECHO = console.log(yytext, yyleng, 1, yyout);
  }

  // Gets input and stuffs it into "buf".  number of characters read, or 
  // YY_NULL, is returned in "result".
  if (YY_INPUT === undefined) {
    YY_INPUT = function (buffer, result, max_size) {
      var c, n;
      if (yy_current_buffer.yy_is_interactive) {
        c = '*';
        
        // loop over character line by line and add characters to buffer
        for (n = 0; n < max_size && (c = getc(yyin) !== EOF && c !== '\n'); n++) {
          buf[n] = c;
        }
        if (c === '\n') {
          if (n >= 1 && buf[n - 1] === '\r') {
            buf[n - 1] = c;
          } else {
            buf[n++] = c;
          }
        }
        if (c === EOF && ferror(yyin)) {
          YY_FATAL_ERROR("input in flex scanner failed");
          result = n;
        }
      } else {
        errno = 0;
        while (result = fread(buf, 1, max_size, yyin) === 0 && ferror(yyin)) {
          if (errno !== EINTR) {
            YY_FATAL_ERROR( "input in flex scanner failed" );
            break;
          }
          errno = 0;
          clearerr(yyin);
        }
        for (n = 0; n < result; n += 1) {
          if (buf[n] === '\n') {
            if (n >= 1 && buf[n - 1] === '\r') {
              buf[n - 1] = '\n';
            }
          }
        }
      }
    };
  }

  // No semi-colon after return; correct usage is to write "yyterminate();" -
  // we don't want an extra ';' after the "return" because that will cause
  // some compilers to complain about unreachable statements.
  if (yyterminate === undefined) {
    yyterminate = function () {
      return YY_NULL;
    };
  }

  // Number of entries by which start-condition stack grows.
  if (YY_START_STACK_INCR === undefined) {
    YY_START_STACK_INCR = 25;
  }

  // Report a fatal error.
  if (YY_FATAL_ERROR === undefined) {
    YY_FATAL_ERROR = function(msg) {
      return yy_fatal_error(msg);
    };
  }

  // Default declaration of generated scanner - a define so the user can
  // easily add parameters.
  if (YY_DECL) {
    // XXX? #define YY_DECL int yylex YY_PROTO(( void ))
    yylex = YY_DECL;
  }
  
  // Code executed at the beginning of each rule, after yytext and yyleng
  // have been set up.
  if (YY_USER_ACTION === undefined) {
    YY_USER_ACTION;
  }

  if (YY_BREAK === undefined) {
    // nah... YY_BREAK = break;
  }

  YY_RULE_SETUP = YY_USER_ACTION;
  
  YY_DECL = function () {
    yy_state_type = yy_current_state;
    yy_cp;
    yy_bp;
    yy_act;
    
    // #line 1 "gram.l"
    
    // #line 1 "gram.l" 
    if (yy_init) {
      yy_init = 0;
 
      if (YY_USER_INIT) {
        YY_USER_INIT;
      }

      // first start state
      if (yy_start === undefined) {
        yy_start = 1;
      }
      if (yyin === undefined) {
        yyin = stdin;
      }
      if (yyout === undefined) {
        yyout = stdout;
      }
      if (yy_current_buffer === undefined) {
        yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE);
      }
      yy_load_buffer_state();
    }

    // oop until end of file is reached
    do {
      yy_cp = yy_c_buf_p;
    
      //XXX? Support of yytext.
      yy_cp = yy_hold_char;

      // yy_bp points to the position in yy_ch_buf of the start of
      // the current run.
      yy_bp = yy_cp;
      
      yy_current_state = yy_start;

    } while (1);

    function yy_match() { 
      do {
        // XXX ?
        YY_CHAR = yy_c = yy_ec[YY_SC_TO_UI(yy_cp)];
        if (yy_accept[yy_current_state]) {
          yy_last_accepting_state = yy_current_state;
          yy_last_accepting_cpos = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] !== yy_current_state) {
          yy_current_state = yy_def[yy_current_state];
          if (yy_current_state >= 33 ) {
            yy_c = yy_meta[yy_c];
          }
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        ++yy_cp;  
      } while (yy_base[yy_current_state] != 40);
    }
    
    function yy_find_action() {
      yy_act = yy_accept[yy_current_state];
      
      // have to back up
      if (yy_act === 0) {
        yy_cp = yy_last_accepting_cpos;
        yy_current_state = yy_last_accepting_state;
        yy_act = yy_accept[yy_current_state];
      }
      YY_DO_BEFORE_ACTION;
    }
    
    // This label is used only to access EOF actions.
    function do_action() {
      
      // beginning of action switch
      switch (yy_act) {
        
        // must back up, undo the effects of YY_DO_BEFORE_ACTION
        case 0:
          yy_cp = yy_hold_char;
          yy_cp = yy_last_accepting_cpos;
          yy_current_state = yy_last_accepting_state;
          return yy_find_action();
        case 1:
          YY_RULE_SETUP();
          // #line 2 "gram.l"
          //{
          yylval = yytext + 1;
          return("TAG");
          //}
          break;
        case 2:
          YY_RULE_SETUP();
          //#line 7 "gram.l"
          //{
          yylval = yytext;
          return("SYMBOL");
          //}
          break;
        case 3:
          YY_RULE_SETUP();
          //#line 12 "gram.l"
          //{
          ModeBlock = 1;
          return("OPEN");
          //}
          break;
        case 4:
          YY_RULE_SETUP();
          //#line 17 "gram.l"
          //{
          ModeBlock = 0;
          return("CLOSE");
          //}
          break;
        case 5:
          YY_RULE_SETUP();
          //#line 22 "gram.l"
          return("CTRL_ASSIGN");
          break;
        case 6:
          YY_RULE_SETUP();
          //#line 23 "gram.l"
          return("CTRL_IGNORE");
          break;
        case 7:
          YY_RULE_SETUP();
          //#line 24 "gram.l"
          return("REVERSE");
          break;
        case 8:
          YY_RULE_SETUP();
          //#line 25 "gram.l"
          return("STARTCLASS");
          break;
        case 9:
          YY_RULE_SETUP();
          //#line 26 "gram.l"
          return("LET");
          break;
        case 10:
          YY_RULE_SETUP();
          //#line 27 "gram.l"
          return("NL");
          break;
        case 11:
          YY_RULE_SETUP();
          //#line 28 "gram.l"
          return("REMARK");
          break;
        case 12:
          YY_RULE_SETUP();
          //#line 29 "gram.l"
          //{};
          break;
        case 13:
          YY_RULE_SETUP();
          //#line 31 "gram.l"
          //{
          errMes("Lexical mistake \"+ yytext +\"");
          return 1;
          //}
          break;
        case 14:
          YY_RULE_SETUP();
          //#line 35 "gram.l"
          ECHO();
          break;
        
        //#line 723 "lex.yy.c"
        case YY_STATE_EOF(INITIAL):
          return yyterminate();
        
        case YY_END_OF_BUFFER:
    
          // Amount of text matched not including the EOB char.
          yy_amount_of_matched_text = (yy_cp - yytext_ptr) - 1;

          // Undo the effects of YY_DO_BEFORE_ACTION.
          yy_cp = yy_hold_char;
          YY_RESTORE_YY_MORE_OFFSET();

          if (yy_current_buffer.yy_buffer_status === YY_BUFFER_NEW ) {

            // We're scanning a new file or input source.  It's
            // possible that this happened because the user
            // just pointed yyin at a new source and called
            // yylex().  If so, then we have to assure
            // consistency between yy_current_buffer and our
            // globals.  Here is the right place to do so, because
            // this is the first action (other than possibly a
            // back-up) that will match for the new input source.
            yy_n_chars = yy_current_buffer.yy_n_chars;
            yy_current_buffer.yy_input_file = yyin;
            yy_current_buffer.yy_buffer_status = YY_BUFFER_NORMAL;
          }

          // Note that here we test for yy_c_buf_p "<=" to the position
          // of the first EOB in the buffer, since yy_c_buf_p will
          // already have been incremented past the NUL character
          // (since all states make transitions on EOB to the
          // end-of-buffer state).  Contrast this with the test
          // in input().

          if (yy_c_buf_p <= yy_current_buffer.yy_ch_buf[yy_n_chars]) {
            // This was really a NUL.
            yy_state_type = yy_next_state;
            yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
            yy_current_state = yy_get_previous_state();
      
            // Okay, we're now positioned to make the NUL
            // transition.  We couldn't have
            // yy_get_previous_state() go ahead and do it
            // for us because it doesn't know how to deal
            // with the possibility of jamming (and we don't
            // want to build jamming into it because then it
            // will run more slowly).
            yy_next_state = yy_try_NUL_trans(yy_current_state);
            yy_bp = yytext_ptr + YY_MORE_ADJ;

            // Consume the NUL.
            if (yy_next_state) {
              yy_cp = ++yy_c_buf_p;
              yy_current_state = yy_next_state;
              yy_match();
            } else {
              yy_cp = yy_c_buf_p;
              yy_find_action();
            }
          } else switch (yy_get_next_buffer()) {
      
            case EOB_ACT_END_OF_FILE:
              yy_did_buffer_switch_on_eof = 0;
              if (yywrap()) {
                
                // Note: because we've taken care in
                // yy_get_next_buffer() to have set up
                // yytext, we can now set up
                // yy_c_buf_p so that if some total
                // hoser (like flex itself) wants to
                // call the scanner after we return the
                // YY_NULL, it'll still work - another
                // YY_NULL will get returned.
                yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
                yy_act = YY_STATE_EOF(YY_START);
                do_action();
              } else {
                if (yy_did_buffer_switch_on_eof === undefined) {
                  YY_NEW_FILE;
                }
              }
              break;
        
            case EOB_ACT_CONTINUE_SCAN:
              yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
              yy_current_state = yy_get_previous_state();
      
              yy_cp = yy_c_buf_p;
              yy_bp = yytext_ptr + YY_MORE_ADJ;
              yy_match();
              break;
            case EOB_ACT_LAST_MATCH:
              yy_c_buf_p = yy_current_buffer.yy_ch_buf[yy_n_chars];
              yy_current_state = yy_get_previous_state();
              yy_cp = yy_c_buf_p;
              yy_bp = yytext_ptr + YY_MORE_ADJ;
              yy_find_action();
          }
        break;
      
      default:
        YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
        break;
      } // end of action switch
    } // end of scanning one token
  }; // end of yylex

  // yy_get_next_buffer - try to read in a new buffer
  //
  // Returns a code representing an action:
  //  EOB_ACT_LAST_MATCH -
  //  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
  //  EOB_ACT_END_OF_FILE - end of file
  yy_get_next_buffer = function () {
    var dest = yy_current_buffer.yy_ch_buf,
      source = yytext_ptr,
      number_to_move,
      i,
      ret_val;
    
    if (yy_c_buf_p > yy_current_buffer.yy_ch_buf[yy_n_chars + 1]) {
      YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");
    }
    
    // Don't try to fill the buffer, so this is an EOF.
    if (yy_current_buffer.yy_fill_buffer === 0) {
      
      // We matched a single character, the EOB, so
      // treat this as a final EOF.
      if (yy_c_buf_p - yytext_ptr - YY_MORE_ADJ === 1) {
        return EOB_ACT_END_OF_FILE;

      // We matched some text prior to the EOB, first
      // process it.
      } else {
        return EOB_ACT_LAST_MATCH;
      }
    }
    
    // Try to read more data.

    // First move last chars to start of buffer.
    number_to_move = (yy_c_buf_p - yytext_ptr) - 1;

    for (i = 0; i < number_to_move; ++i) {
      //XXX *(dest++) = *(source++);
      dest[i] = source[i];
    }

    // don't do the read, it's not guaranteed to return an EOF,
    // just force an EOF
    if (yy_current_buffer.yy_buffer_status === YY_BUFFER_EOF_PENDING) {
      yy_current_buffer.yy_n_chars = yy_n_chars = 0;

    } else {
      num_to_read = yy_current_buffer.yy_buf_size - number_to_move - 1;

      // Not enough room in the buffer - grow it.
      while (num_to_read <= 0) {
        
        if (YY_USES_REJECT) {
          YY_FATAL_ERROR("input buffer overflow, can't enlarge buffer because scanner uses REJECT");
        } else {

          // just a shorter name for the current buffer
          b = yy_current_buffer;
          yy_c_buf_p_offset = (yy_c_buf_p - b.yy_ch_buf);

          if (b.yy_is_our_buffer) {
            new_size = b.yy_buf_size * 2;

            if (new_size <= 0) {
              b.yy_buf_size += b.yy_buf_size / 8;
            } else {
              b.yy_buf_size = 2;
            }
        
            b.yy_ch_buf;
          
            // Include room in for 2 EOB chars.
            yy_flex_realloc(b.yy_ch_buf, b.yy_buf_size + 2);
          
          } else {
            
            // Can't grow it, we don't own it.
            b.yy_ch_buf = 0;
          }
      
          if (b.yy_ch_buf === undefined) {
            YY_FATAL_ERROR("fatal error - scanner input buffer overflow");
          }

          yy_c_buf_p = b.yy_ch_buf[yy_c_buf_p_offset];
          num_to_read = yy_current_buffer.yy_buf_size - number_to_move - 1;
        }

        if (num_to_read > YY_READ_BUF_SIZE) {
          num_to_read = YY_READ_BUF_SIZE;
        }
        
        // Read in more data.
        YY_INPUT((yy_current_buffer.yy_ch_buf[number_to_move]), yy_n_chars, num_to_read);
        yy_current_buffer.yy_n_chars = yy_n_chars;
      }
    
      if (yy_n_chars === 0) {
        if (number_to_move === YY_MORE_ADJ ) {
          ret_val = EOB_ACT_END_OF_FILE;
          yyrestart(yyin);
        } else {
          ret_val = EOB_ACT_LAST_MATCH;
          yy_current_buffer.yy_buffer_status = YY_BUFFER_EOF_PENDING;
        }
      } else {
        ret_val = EOB_ACT_CONTINUE_SCAN;
      }
    
      yy_n_chars += number_to_move;
      yy_current_buffer.yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
      yy_current_buffer.yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
    
      yytext_ptr = yy_current_buffer.yy_ch_buf[0];
      return ret_val;
    }
  };

  // yy_get_previous_state - get the state just before the EOB char was reached.
  yy_state_type = function yy_get_previous_state() {
    var yy_state_type = yy_current_state,
      yy_cp;

    yy_current_state = yy_start;

    for (yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp) {
      //YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
      yy_c = (yy_cp ? yy_ec[YY_SC_TO_UI(yy_cp)] : 1);
      if (yy_accept[yy_current_state]) {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos = yy_cp;
      }
      while (yy_chk[yy_base[yy_current_state] + yy_c] !== yy_current_state) {
        yy_current_state = yy_def[yy_current_state];
        if (yy_current_state >= 33) {
          yy_c = yy_meta[yy_c];
        }
      }
      yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    }
    return yy_current_state;
  };


  // yy_try_NUL_trans - try to make a transition on the NUL character
  //
  // synopsis
  //  next_state = yy_try_NUL_trans( current_state );
  if (YY_USE_PROTOS) {
    yy_state_type = yy_try_NUL_trans(yy_current_state);
  } else {
    yy_state_type = yy_try_NUL_trans(yy_current_state);
  }

  yy_try_NUL_trans = function (yy_current_state){
    yy_is_jam;
    yy_cp = yy_c_buf_p;
    yy_c = 1;
    if (yy_accept[yy_current_state]) {
      yy_last_accepting_state = yy_current_state;
      yy_last_accepting_cpos = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] !== yy_current_state) {
      yy_current_state = yy_def[yy_current_state];
      if (yy_current_state >= 33) {
        yy_c = yy_meta[yy_c];
      }
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    yy_is_jam = (yy_current_state == 32);
  
    return yy_is_jam ? 0 : yy_current_state;
  };

  if (YY_NO_UNPUT === undefined) {
    if (YY_USE_PROTOS) {
      //yyunput = function(c, yy_bp);
    } else {
      //yyunput = function(c, yy_bp);
    }
    yyunput = function (c, yy_bp) {
      yy_cp = yy_c_buf_p;
    
      // undo effects of setting up yytext
      yy_cp = yy_hold_char;
    
      // need to shift things up to make room
      if (yy_cp < yy_current_buffer.yy_ch_buf + 2) { 

        // +2 for EOB chars.
        number_to_move = yy_n_chars + 2;
        dest = yy_current_buffer.yy_ch_buf[yy_current_buffer.yy_buf_size + 2];
        source = yy_current_buffer.yy_ch_buf[number_to_move];
        while (source > yy_current_buffer.yy_ch_buf) {
          //XXX*--dest = *--source;
        }
        yy_cp += (dest - source);
        yy_bp += (dest - source);
        yy_current_buffer.yy_n_chars = yy_n_chars = yy_current_buffer.yy_buf_size;
        if (yy_cp < yy_current_buffer.yy_ch_buf + 2 ) {
          YY_FATAL_ERROR("flex scanner push-back overflow");
        }
      }
      // XXX? *--yy_cp = (char) c;
      yy_cp = c;
      yytext_ptr = yy_bp;
      yy_hold_char = yy_cp;
      yy_c_buf_p = yy_cp;
    };
  }

  if (__cplusplus) {
    //yyinput();
  } else {
    //input();
  }

  input = function()  {
    var c;

    yy_c_buf_p = yy_hold_char;

    // yy_c_buf_p now points to the character we want to return.
    // If this occurs *before* the EOB characters, then it's a
    // valid NUL; if not, then we've hit the end of the buffer.
    if (yy_c_buf_p === YY_END_OF_BUFFER_CHAR) {
    
      // This was really a NUL.
      if (yy_c_buf_p < yy_current_buffer.yy_ch_buf[yy_n_chars]) {
        yy_c_buf_p = '\0';
      
      // need more input
      } else {
        offset = yy_c_buf_p - yytext_ptr;
        ++yy_c_buf_p;

        switch (yy_get_next_buffer()) {
          
          // This happens because yy_g_n_b()
          // sees that we've accumulated a
          // token and flags that we need to
          // try matching the token before
          // proceeding.  But for input(),
          // there's no matching to consider.
          // So convert the EOB_ACT_LAST_MATCH
          // to EOB_ACT_END_OF_FILE.
          case EOB_ACT_LAST_MATCH:
          
            // Reset buffer status.
            return yyrestart(yyin);
  
          //fall through
          case EOB_ACT_END_OF_FILE:
            if (yywrap()) {
              return EOF;
            }
            if (yy_did_buffer_switch_on_eof === undefined) {
              YY_NEW_FILE;
              if (__cplusplus) {
                return yyinput();
              } else {
                return input();
              }
            }
            break;

          case EOB_ACT_CONTINUE_SCAN:
            yy_c_buf_p = yytext_ptr + offset;
            break;
        }
      }
    }

    // cast for 8-bit char's
    c = yy_c_buf_p;
    
    // preserve yytext 
    yy_c_buf_p = '\0';  
    yy_hold_char = ++yy_c_buf_p;
    return c;
  };

  if (YY_USE_PROTOS) {
    // yyrestart();
  } else {
    // yyrestart();
  }
  yyrestart = function (input_file) {
    if (yy_current_buffer === undefined) {
      yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE);
    }
    yy_init_buffer(yy_current_buffer, input_file);
    yy_load_buffer_state();
  };

  if (YY_USE_PROTOS) {
    // yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
  } else {
    // yy_switch_to_buffer( new_buffer ) 
    YY_BUFFER_STATE = new_buffer;
  }
  yy_switch_to_buffer = function () {
    if (yy_current_buffer === new_buffer) {
      return;
    }

    // Flush out information for old buffer.
    if (yy_current_buffer) {
      yy_c_buf_p = yy_hold_char;
      yy_current_buffer.yy_buf_pos = yy_c_buf_p;
      yy_current_buffer.yy_n_chars = yy_n_chars;
    }

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();

    // We don't actually know whether we did this switch during
    // EOF (yywrap()) processing, but the only time this flag
    // is looked at is after yywrap() is called, so it's safe
    // to go ahead and always set it.
    yy_did_buffer_switch_on_eof = 1;
  };

  
  if (YY_USE_PROTOS) {
    //yy_load_buffer_state(void)
  } else {
    //yy_load_buffer_state()
  }

  yy_load_buffer_state = function () {
    yy_n_chars = yy_current_buffer.yy_n_chars;
    yytext_ptr = yy_c_buf_p = yy_current_buffer.yy_buf_pos;
    yyin = yy_current_buffer.yy_input_file;
    yy_hold_char = yy_c_buf_p;
  };

  if (YY_USE_PROTOS) {
    // YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
  } else {
    // YY_BUFFER_STATE yy_create_buffer( file, size )
  }
  yy_create_buffer = function(file, size) {
    // XXX ? YY_BUFFER_STATE = b;
    //YY_BUFFER_STATE = b;
    b = YY_BUFFER_STATE;
    yy_flex_alloc(sizeof(yy_buffer_state));
    
    if (b === undefined) {
      YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");
    }
    b.yy_buf_size = size;
  
    // yy_ch_buf has to be 2 characters longer than the size given because
    // we need to put in 2 end-of-buffer characters.
    b.yy_ch_buf = yy_flex_alloc(b.yy_buf_size + 2 );
    if (b.yy_ch_buf === undefined) {
      YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");
    }
    b.yy_is_our_buffer = 1;
    yy_init_buffer(b, file);
    return b;
  };

  if (YY_USE_PROTOS) {
    // yy_delete_buffer( YY_BUFFER_STATE b )
  } else {
    // yy_delete_buffer( b )
  }

  yy_delete_buffer = function (b) {
    if (b === undefined) {
      return;
    }
    if (b === yy_current_buffer) {
      yy_current_buffer = 0;
    }
    if (b.yy_is_our_buffer) {
      yy_flex_free(b.yy_ch_buf);
    }
    yy_flex_free(b);
  };

  if (_WIN32 === undefined) {
    // #include <unistd.h>
  } else {
    if (YY_ALWAYS_INTERACTIVE === undefined) {
      if (YY_NEVER_INTERACTIVE === undefined) {
        // extern int isatty YY_PROTO(( int ));        
      }
    }    
  }
  
  if (YY_USE_PROTOS) {
    // void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
  } else {
    //yy_init_buffer( b, file );
  }
  yy_init_buffer = function (b, file) {
    yy_flush_buffer(b);

    b.yy_input_file = file;
    b.yy_fill_buffer = 1;
    if (YY_ALWAYS_INTERACTIVE) {
      b.yy_is_interactive = 1;
    } else if (YY_NEVER_INTERACTIVE) {
      b.yy_is_interactive = 0;
    } else {
      b.yy_is_interactive = file ? /* (isatty( fileno(file) ) > 0) */ 1 : 0;
    }
  };

  if (YY_USE_PRoTOS) {
    // void yy_flush_buffer( YY_BUFFER_STATE b )
  } else {
    // void yy_flush_buffer( b )
    // YY_BUFFER_STATE b;
  }
  
  yy_flush_buffer = function (b) {
    if (b === undefined) {
      return;
    }

    b.yy_n_chars = 0;

    // We always need two end-of-buffer characters.  The first causes
    // a transition to the end-of-buffer state.  The second causes
    // a jam in that state.
    b.yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b.yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
  
    b.yy_buf_pos = b.yy_ch_buf[0];
  
    b.yy_at_bol = 1;
    b.yy_buffer_status = YY_BUFFER_NEW;
  
    if (b === yy_current_buffer) {
      yy_load_buffer_state();
    }
  };

  if (YY_NO_SCAN_BUFFER === undefined) {
    if (YY_USE_PROTOS === undefined) {
      // YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
    } else {
      // YY_BUFFER_STATE yy_scan_buffer( base, size )      
    }
    yy_scan_buffer = function (base, size) {
      YY_BUFFER_STATE = b;

      // They forgot to leave room for the EOB's.
      if (size < 2 || base[size - 2] !== YY_END_OF_BUFFER_CHAR || base[size - 1] !== YY_END_OF_BUFFER_CHAR) {
        return 0;
      }

      b = yy_flex_alloc(sizeof(yy_buffer_state));
      if (b === undefined) {
        YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");
      }
      b.yy_buf_size = size - 2;  // "- 2" to take care of EOB's/
      b.yy_buf_pos = b.yy_ch_buf = base;
      b.yy_is_our_buffer = 0;
      b.yy_input_file = 0;
      b.yy_n_chars = b.yy_buf_size;
      b.yy_is_interactive = 0;
      b.yy_at_bol = 1;
      b.yy_fill_buffer = 0;
      b.yy_buffer_status = YY_BUFFER_NEW;
      yy_switch_to_buffer(b);
      return b; 
    };
  }

  if (YY_NO_SCAN_STRING === undefined) {
    if (YY_NO_PROTOS) {
      // YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
    } else {
      // YY_BUFFER_STATE yy_scan_string( yy_str )
      // yyconst char *yy_str;
    }
    yy_scan_string = function (yy_str) {
      var len;
      for (len = 0; yy_str[len]; ++len) {
        ;
      }

      return yy_scan_bytes(yy_str, len);
    };
  }

  if (YY_NO_SCAN_BYTES) {
    if (YY_USE_PROTOS) {
      // YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
    } else {
      // YY_BUFFER_STATE yy_scan_bytes( bytes, len )
      // yyconst char *bytes;
      // int len;      
    }
    yy_scan_bytes = function (bytes, len) {
      var buf,
        i,
        b = YY_BUFFER_STATE,
        n = yy_size_t;

      // Get memory for full buffer, including space for trailing EOB's.
      n = len + 2;
      buf = yy_flex_alloc( n );
      if (buf === undefined) {
        YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");
      }
      for (i = 0; i < len; ++i) {
        buf[i] = bytes[i];
      }
      buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
    
      b = yy_scan_buffer(buf, n);
      if (b === undefined) {
        YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
      }
      // It's okay to grow etc. this buffer, and we should throw it
      // away when we're done.
      b.yy_is_our_buffer = 1;

      return b;
    };
  }
  
  if (YY_NO_PUSH_STATE === undefined) {
    if (YY_NO_PROTOS) {
      // static void yy_push_state( int new_state )
    } else {
      // static void yy_push_state( new_state )
      // int new_state;      
    }
    yy_push_state = function (new_state) {
      if (yy_start_stack_ptr >= yy_start_stack_depth) {
        yy_size_t = new_size;
  
        yy_start_stack_depth += YY_START_STACK_INCR;
        new_size = yy_start_stack_depth * sizeof(int);
  
        if (yy_start_stack === undefined) {
          yy_start_stack = yy_flex_alloc(new_size);
        } else {
          yy_start_stack = yy_flex_realloc(yy_start_stack, new_size);
        }
        if (yy_start_stack === undefined) {
          YY_FATAL_ERROR("out of memory expanding start-condition stack");
        }
      }
      yy_start_stack[yy_start_stack_ptr++] = YY_START;
      BEGIN(new_state);
    };
  }

  if (YY_NO_POP_STATE === undefined) {
    yy_pop_state = function () {
      if (--yy_start_stack_ptr < 0) {
        YY_FATAL_ERROR( "start-condition stack underflow" );
      }
      BEGIN(yy_start_stack[yy_start_stack_ptr]);
    };
  }
  if (YY_NO_TOP_STATE === undefined) {
    yy_no_top_state = function () {
      return yy_start_stack[yy_start_stack_ptr - 1];
    };
  }

  if (YY_EXIT_FAILURE === undefined) {
    YY_EXIT_FAILURE = 2;
  }

  if (YY_USE_PROTOS) {
    // static void yy_fatal_error( yyconst char msg[] )
  } else {
    // static void yy_fatal_error( msg )
    // char msg[];
  }
  yy_fatal_error = function (msg) {
    console.log("stderr", msg + "\n");
    exit(YY_EXIT_FAILURE);
  };

  // Redefine yyless() so it works in section 3 code.
  yyless = null;
  yyless = function (n) {
    // do {
    // Undo effects of setting up yytext.
    yytext[yyleng] = yy_hold_char;
    yy_c_buf_p = yytext + n;
    yy_hold_char = yy_c_buf_p;
    yy_c_buf_p = '\0';
    yyleng = n;
    // } while (0);
  };

  // Internal utility routines.
  
  if (yytext_ptr === undefined) {
    if (YY_USE_PROTOS) {
      // static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
    } else {
      // static void yy_flex_strncpy( s1, s2, n )
      // char *s1;
      // yyconst char *s2;
      // int n;
    }
    yy_flex_strncpy = function (s1, s2, n) {
      var i;
      for (i = 0; i < n; ++i) {
        s1[i] = s2[i];
      }
    };  
  }

  if (YY_NEED_STRLEN) {
    if (YY_USE_PROTOS) {
      // static int yy_flex_strlen( yyconst char *s )
    } else {
      // static int yy_flex_strlen( s )
      // yyconst char *s; 
    }
    yy_flex_strlen = function (s) {
      for (n = 0; s[n]; ++n) {
        ;
      }
      return n;
    };
  }

  if (YY_USE_PROTOS) {
    // static void *yy_flex_alloc( yy_size_t size )
  } else {
    // static void *yy_flex_alloc( size )
    // yy_size_t size;    
  }
  yy_flex_alloc = function (size) {
    // return (void *) malloc( size );
    return new ArrayBuffer(size);
  };

  if (YY_USE_PROTOS) {
    // static void *yy_flex_realloc( void *ptr, yy_size_t size )
  } else {
    // static void *yy_flex_realloc( ptr, size )
    // void *ptr;
    // yy_size_t size;
  }
  yy_flex_realloc = function (ptr, size) {
    // The cast to (char *) in the following accommodates both
    // implementations that use char* generic pointers, and those
    // that use void* generic pointers.  It works with the latter
    // because both ANSI C and C++ allow castless assignment from
    // any pointer type to void*, and deal with argument conversions
    // as though doing an assignment.
    // return (void *) realloc( (char *) ptr, size );
    // XXX hm
  };

  if (YY_USE_PROTOS) {
    // static void yy_flex_free( void *ptr )    
  } else {
    // static void yy_flex_free( ptr )
    // void *ptr;    
  }
  yy_flex_free = function (ptr) {
    // XXX ? free(ptr);
  };

  if (YY_MAIN) {
    main = function () {
      yylex();
      return 0;
    };
  }
  // #line 35 "gram.l"

}());


