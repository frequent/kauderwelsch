(function (window, YY) {
  "use strict";

  /*
   * Copyright (c) 1991-2011 Kawahara Lab., Kyoto University
   * Copyright (c) 2000-2005 Shikano Lab., Nara Institute of Science and Technology
   * Copyright (c) 2005-2011 Julius project team, Nagoya Institute of Technology
   * All rights reserved
   */
   
  // A lexical scanner generated by flex
  // Scanner skeleton version:
  // $Header: /cvsroot/julius/julius4/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c,v 1.7 2013/06/20 17:14:18 sumomo Exp $

  // ported from:
  // https://github.com/julius-speech/julius/blob/6d135a686a74376495a7a6f55d3d67df54186f83/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c
  // http://www.isi.edu/~pedro/Teaching/CSCI565-Fall16/Materials/LexAndYaccTutorial.pdf
  // https://github.com/aaditmshah/lexer
  // https://github.com/codemix/malloc
  // http://epaperpress.com/lexandyacc/prl.html
  // https://ds9a.nl/lex-yacc/cvs/lex-yacc-howto.html
  // https://www.coin-or.org/Doxygen/OS/structyyguts__t.html
  // http://www.cs.man.ac.uk/~pjj/cs211/ho/node6.html
  // https://jsperf.com/arraybuffer-string-conversion/4

  var lex;

  // as before single YY
  if (YY === undefined) {
    throw new Error("YY is not defined.");
  }

  // (YY_SC_TO_UI)
  // Promotes a possibly negative, possibly signed char to an unsigned
  // integer for use as an array index.  If the signed char is negative,
  // we want to instead treat it as an 8-bit unsigned char, hence the
  // double cast.
  // #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
  function doubleCast(my_c) {
    return my_c;
  }

  YY.lexer_dict = {};

  // save some code
  lex = YY.lexer_dict;

  // ----------------------------- Tables --------------------------------------

  lex.table_dict = {

    // (yy_ec) - ??
    "ec": [
      0,
      1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    2,    4,    1,    5,    1,    6,    1,    1,    1,
      1,    7,    1,    1,    1,    1,    1,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    9,    1,    1,
      1,    1,    1,   10,   11,    8,    8,    8,   12,    8,
     13,    8,   14,    8,    8,    8,    8,   15,   16,    8,
      8,   17,   18,    8,    8,    8,    8,    8,    8,    8,
      1,    1,    1,    1,    8,    1,    8,    8,    8,    8,
  
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,   19,    1,   20,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
  
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1
    ],

    // (yy_accept) - ??
    "accept": [
        0,
        0,    0,   15,   13,   12,   10,    7,   13,   13,    8,
        2,    9,   13,    3,    4,    0,   11,    0,    0,    2,
        1,    0,    0,    0,    0,    0,    0,    0,    0,    5,
        6,    0
    ],
    
    // (yy_base)
    "base": [
      0,
      0,    0,   39,   40,   40,   40,   40,   35,   10,   40,
      0,   40,    0,   40,   40,   34,   40,   18,   22,    0,
      0,   16,   18,   18,   15,   17,   12,   13,   15,   40,
     40,   40,   24,   21,   20
    ],

    // (yy_meta)
    "meta": [
      0,
      1,    1,    1,    1,    1,    1,    1,    2,    1,    1,
      2,    2,    2,    2,    2,    2,    2,    2,    1,    1
    ],

    // (yy_def)
    "def": [
       0,
       32,    1,   32,   32,   32,   32,   32,   33,   32,   32,
       34,   32,   35,   32,   32,   33,   32,   32,   32,   34,
       35,   32,   32,   32,   32,   32,   32,   32,   32,   32,
       32,    0,   32,   32,   32
    ],

    // (yy_nxt)
    "nxt": [
      0,
      4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
     11,   11,   11,   11,   11,   11,   11,   11,   14,   15,
     18,   21,   20,   19,   16,   16,   31,   30,   29,   28,
     27,   26,   25,   24,   23,   22,   17,   17,   32,    3,
     32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
     32,   32,   32,   32,   32,   32,   32,   32,   32,   32
    ],

    // (yy_chk)
    "check": [
      0,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      9,   35,   34,    9,   33,   33,   29,   28,   27,   26,
     25,   24,   23,   22,   19,   18,   16,    8,    3,   32,
     32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
     32,   32,   32,   32,   32,   32,   32,   32,   32,   32
    ]
  };

  // ------------------------------ Setup --------------------------------------
  
  // (yy_c) character - only used as internal counter
  // lex.character;
  
  // (YY_NULL) - returned upon end-of-file.
  lex.nullinger = 0;
  
  // (INITIAL) - #line 1 "gram.l"
  lex.initial = 0;

  // (YY_MORE_ADJ)ust? this will never be set, useless?
  lex.more_adjust = 0;
  
  // (YY_END_OF_BUFFER)
  lex.buffer_end = 15;
  
  // (YY_READ_BUF_SIZE) - Amount of stuff to slurp up with each read.
  lex.buffer_read_chunk_size = 8192;

  // (YY_END_OF_BUFFER_CHAR)
  lex.buffer_end_character = 0;

  // (yy_did_buffer_switch_on_eof) Flag which is used to allow 
  // lex.thatsAWrap()'s to do buffer switches instead of setting up a fresh 
  // yyin.  A bit of a hack ...
  lex.buffer_switched_on_end_of_file;

  // (EOB_ACT_CONTINUE_SCAN)
  lex.end_of_block_action_continue_scan = 0;

  // (EOB_ACT_END_OF_FILE)
  lex.end_of_block_action_end_of_file = 1;

  // (EOB_ACT_LAST_MATCH)
  lex.end_of_block_action_last_match = 2;

  // (YY_BUFFER_EOF_PENDING)
  // When an EOF's been seen but there's still some text to process
  // then we mark the buffer as YY_EOF_PENDING, to indicate that we
  // shouldn't try reading from the input source any more.  We might
  // still have a bunch of tokens to match, though, because of
  // possible backing-up.
  //
  // When we actually see the EOF, we change the status to "new"
  // (via lex.restartLex()), so that the user can continue scanning by
  // just pointing file input (yyin) at a new input file.
  // declared inside buffer state dict, not sure this can be pulled out
  lex.buffer_eof_pending = 2;
  
  // (YY_BUFFER_NEW) what elaborate way to say 0...
  // declared inside buffer state dict, not sure this can be pulled out
  lex.buffer_is_new = 0;

  // (YY_BUFFER_NORMAL)
  // declare inside buffer state dict,not sure this can be pulled out
  lex.buffer_is_normal = 1;

  // (yyin) file input file
  lex.file_input;

  // (yyout) file output file
  lex.file_output;

  // (yyleng) is the length of the matched string
  lex.matched_string_len;
  
  // (yy_amount_of_matched_text)
  lex.amount_of_matched_text;
    
  // (yytext) is a pointer to the matched string (NULL-terminated)
  lex.matched_string;

  // (yytext_ptr) => #define yytext_ptr yytext, a macro pointing to yytext
  // why not use it directly?
  lex.matched_string_pseudo_pointer = 0;
  
  // (yy_cp) int
  lex.current_run_character_position;

  // (yy_bp) int points to the position in yy_ch_buf of the start of
  // the current run.
  lex.current_run_buffer_start_position;

  // (YY_USES_REJECT) - not defined, whether memory can be grown XXX REMOVE
  lex.uses_reject = 0;

  // (yy_init) whether we need to initialize - XXX REMOVE
  lex.init = 1;

  // (YY_ALWAYS_INTERACTIVE) - XXX REMOVE
  lex.always_interactive = 0;
  
  // (YY_NEVER_INTERACTIVE) - XXX REMOVE
  lex.never_interactive = 0;

  // (YY_BUF_SIZE) Size of default input buffer.
  lex.buffer_size = 16384;

  // (yy_last_accepting_cpos)
  lex.last_accepting_character_position;
  
  // (yy_last_accepting_state)
  lex.last_accepting_state;

  // (yy_current_buffer)
  lex.current_buffer;
  
  // (yy_hold_char) holds the character lost when yytext is formed.
  lex.tmp_character_hold;

  // (yy_n_chars) number of characters read into yy_ch_buf
  // CAREFUL, also defined inside state buffer...
  lex.buffer_character_len;

  // (yy_start) Start state number
  lex.start_state = 0;
  
  // (yy_current_state) pulled out it is declared in parse but used elsewhere
  lex.current_state;

  // (yy_next_state) only used in do_action
  lex.next_state;

  // (action_to_run)
  lex.action_to_run;

  // (YY_START) macro
  // Translate the current start state into a value that can be later handed
  // to BEGIN to return to the state.  The YYSTATE alias is for lex
  // compatibility.
  lex.start_state_confusulation = (lex.start_state - 1)/2;

  // (yy_c_buf_p) int Points to current character [position] in buffer.
  // (char *) 0; => Not a null character. Pointer to a character at address 0.
  lex.current_run_buffer_character_position = 0;

  // (yywrap) um, remove, too
  lex.thatsAWrap = function () {
    return 1;
  };

  // (yy_load_buffer_state)
  lex.loadBufferState = function () {
    lex.buffer_character_len = lex.current_buffer.buffer_state_character_len;
    lex.matched_string_pseudo_pointer = lex.current_run_buffer_character_position = lex.current_buffer.buffer_state_current_position;
    lex.file_input = lex.current_buffer.buffer_state_input_file;
    lex.tmp_character_hold = lex.current_run_buffer_character_position;
  };

  // (yy_buffer_state)
  lex.getBufferStateDict = function () {
    return {

      // the file (yy_input_file)
      buffer_state_input_file: null,

      // (yy_is_interactive) Whether this is an "interactive" input source; 
      // if so, and if we're using stdio for input, then we want to use getc()
      // instead of fread(), to make sure we stop fetching input after 
      // each newline.
      buffer_state_interactive_input: null,

      // (yy_fill_buffer) Whether to try to fill the input buffer when we 
      // reach the end of it.
      buffer_state_fill_if_full: null,

      // (yy_buf_size type = yy_size_t) - Size of input buffer in bytes, not 
      // including room for EOB characters.
      buffer_state_size: null,

      // (yy_is_our_buffer) Whether we "own" the buffer - i.e., we know we 
      // created it, can realloc() it to grow and should free() it to delete it.
      buffer_is_ours: null,

      // (yy_ch_buf) input buffer
      buffer_state_array_buffer: null,

      // (yy_n_chars) Number of characters read into yy_ch_buf, not including 
      // EOB characters.
      buffer_state_character_len: null,

      // (yy_buf_pos) current position in input buffer
      buffer_state_current_position: null,

      // (yy_buffer_status)
      buffer_status: null,

      // (yy_at_bol) Whether we're considered to be at the beginning of a line.
      // If so, '^' rules will be active on the next match, otherwise not.
      input_line_start: null,

      // added to reset whatever was #defined here, namely
      resetPseudoGlobalsSetInBuffer: function () {
        lex.buffer_eof_pending = 2;
        lex.buffer_is_new = 0;
        lex.buffer_is_normal = 1;
      }
    };
  };

  // (yy_set_interactive) not used REMOVE
  lex.setLexterToInteractive = function (my_interactive) {
    if (lex.current_buffer === undefined) {
      lex.current_buffer = lex.createBuffer(lex.file_input, lex.default_buffer_size);
      lex.current_buffer.buffer_state_interactive_input = my_interactive;
    } else {
      throw new Error("[error] - Don't switch interactive after creating buffer...");
    }
  };
  
  // (yy_init_buffer) load file into buffer state
  lex.restoreOriginalOffset = function (my_buffer, my_file) {
    yy_flush_buffer(b);

    b.buffer_state_input_file = my_file;
    b.buffer_state_fill_if_full = 1;
    if (lex.always_interactive) {
      b.buffer_state_interactive_input = 1;
    } else if (lex.never_interactive) {
      b.buffer_state_interactive_input = 0;
    } else {

      // http://stackoverflow.com/questions/36258224/what-is-isatty-in-c-for      
      b.buffer_state_interactive_input = my_file ? /* (isatty( fileno(file) ) > 0) */ 1 : 0;
    }
  };

  // (YY_INPUT) Gets input and stuffs it into "buf". Number of characters read,
  // or nullinger is returned in "result".
  lex.readChunkFromInput = function (my_buffer_top, my_character_len, my_chunk_size) {
    var input_len = lex.file_input.byteLength,
      view = lex.current_buffer.buffer_state_array_buffer,
      current_character_position,
      n,
      character;
    
    // XXX var c = '*'; why?

    if (lex.current_buffer.buffer_state_interactive_input) {
      for (n = 0; n < my_chunk_size && (my_buffer_top + n) < input_len; n += 1) {
        current_character_position = my_buffer_top + n;
        character = lex.file_input.charCodeAt(current_character_position);

        // line break
        if (character === '\n') {
          if (n >= 1 && view.getInt8(current_character_position - 1) === '\r') {
            view.setInt8(current_character_position - 1, character);
          } else {
            view.setInt8(current_character_position++, character);
          }

        // end of file, only here we set character_len?
        } else if (current_character_position === input_len) {
          lex.buffer_character_len = current_character_position;

        // normal character
        } else {
          view.setInt8(current_character_position + character);
        }
      }
    } else {
      // XXX real time lexing?
    }
  };

  // (yy_flex_realloc) move to a larger arraybuffer
  lex.growCurrentBuffer = function (my_new_size) {
    var new_buffer = new ArrayBuffer(my_new_size),
      new_data_view = new DataView(new_buffer),
      current_view = lex.current_buffer.buffer_state_array_buffer,
      len = lex.current_buffer.buffer_state_array_buffer.byteLength,
      i;
    for (i = 0; i < len; i += 1) {
      new_data_view.setInt8(i, current_view.getInt8(i));
    }
    lex.current_buffer.buffer_state_actual_buffer = new_buffer;
    lex.current_buffer.buffer_state_array_buffer = new_data_view;
  };

  lex.setBuffer = function (my_size) {
    return new ArrayBuffer(my_size);
  };

  // (yy_create_buffer)
  lex.createBuffer = function (my_file, my_size) {
    var b = getBufferStateDict();

    // removed out of dynamic memory test on createBuffer

    b.resetPseudoGlobalsSetInBuffer();
    b.buffer_state_size = my_size;

    // yy_ch_buf has to be 2 characters longer than the size given because
    // we need to put in 2 end-of-buffer characters.
    b.buffer_state_actual_buffer = lex.setBuffer(b.buffer_state_size + 2);
    b.buffer_state_array_buffer = new DataView(b.buffer_state_actual_buffer);

    b.buffer_is_ours = 1;
    lex.initBuffer(b, my_file);
    return b;
  };

  // (YY_RESTORE_YY_MORE_OFFSET) - XXX not really sure what this is supposed
  // to do.
  lex.restoreOriginalOffset = function () {
    lex.matched_string;
  };

  
  // (YY_USER_ACTION)
  // Code executed at the beginning of each rule, after lex.matched_string
  // (yytext) and lex.matched_string_len (yyleng) have been set up.
  // pass this into lexer, my_param?
  if (lex.userAction === undefined) {
    lex.userAction = function () {
      return;
    };
  }

  // (YY_STATE_EOF) Action number for EOF rule of a given start state.
  lex.setEofState = function (my_state) {
    return lex.buffer_end + my_state + 1;
  };
  
  //(YY_RULE_SETUP = YY_USER_ACTION)
  lex.ruleSetup = function () {
    return lex.userAction();
  };
  
  // (ECHO) Copy whatever the last rule matched to the standard output.
  // This used to be an fputs(), but since the string might contain NUL's,
  // we now use fwrite().
  // write from array to stream, but where does it end up?
  //XXX ECHO = fwrite(yytext, yyleng, 1, yyout);
  lex.echo = function () {
    console.log("[echo], but what to do with stdoutput:");
    console.log(lex.matched_string, lex.matched_string_len, 1, lex.file_output);
  };

  // (yyterminate) No semi-colon after return; correct usage is to write 
  // "yyterminate();" - we don't want an extra ';' after the "return" because 
  // that will cause some compilers to complain about unreachable statements.
  lex.terminate = function () {
    return lex.nullinger;
  };

  // (GOTO yy_match)
  // not sure this is so easy to take out and the code is just executed 
  // disregarding the goto
  lex.matchText = function () {
    var counter;
    do {
      counter = lex.table_dict.ec[doubleCast(lex.current_run_character_position)];

      if (lex.table_dict.accept[lex.current_state]) {
        lex.last_accepting_state = lex.current_state;
        lex.last_accepting_character_position = lex.current_run_character_position;
      }

      while (lex.table_dict.check[lex.table_dict.base[lex.current_state] + counter] !== lex.current_state) {
        lex.current_state = lex.table_dict.def[lex.current_state];
        if (lex.current_state >= 33 ) {
          counter = lex.table_dict.meta[counter];
        }
      }
      lex.current_state = lex.table_dict.nxt[lex.table_dict.base[lex.current_state] + counter];
      lex.current_run_character_position = lex.current_run_character_position + 1;

    } while (lex.table_dict.base[lex.current_state] !== 40);
  };

  // (yy_try_NUL_trans) - try to make a transition on the NUL character
  // synopsis: next_state = yy_try_NUL_trans( current_state );
  lex.attemptNulTransition = function (my_lexer_current_state){
    var counter = 1;
      //is_jammed;

    lex.current_run_character_position = lex.current_run_buffer_character_position;
    if (lex.table_dict.accept[my_lexer_current_state]) {
      lex.last_accepting_state = my_lexer_current_state;
      lex.last_accepting_character_position = lex.current_run_character_position;
    }
    while (lex.table_dict.check[lex.table_dict.base[my_lexer_current_state] + counter] !== my_lexer_current_state) {
      my_lexer_current_state = lex.table_dict.def[my_lexer_current_state];
      if (my_lexer_current_state >= 33) {
        counter = lex.table_dict.meta[counter];
      }
    }
    my_lexer_current_state = lex.table_dict.nxt[lex.table_dict.base[my_lexer_current_state] + counter];
    //is_jammed = (my_lexer_current_state === 32);

    // if (is_jammed) {
    if (my_lexer_current_state === 32) {
      return 0;
    }
    return my_lexer_current_state;
  };

  // (yy_get_previous_state) - get state just before the EOB char was reached.
  lex.getPreviousState = function () {
    var tmp_lexer_current_state = lex.start_state,
      counter;

    // oulala
    for (lex.current_run_character_position = lex.matched_string_pseudo_pointer + lex.more_adjust; lex.current_run_character_position < lex.current_run_buffer_character_position; ++lex.current_run_character_position) {

      //YY_CHAR  (yy_c) = (*lex.current_run_character_position ? yy_ec[doubleCast(*lex.current_run_character_position)] : 1);
      // counter = (lex.current_run_character_position ? lex.table_dict.ec[doubleCast(lex.current_run_character_position)] : 1);
      if (lex.current_run_character_position) {
        counter = lex.table_dict.ec[doubleCast(lex.current_run_character_position)];
      } else {
        counter = 1;
      }
      // never changes?
      if (lex.table_dict.accept[tmp_lexer_current_state]) {
        lex.last_accepting_state = tmp_lexer_current_state;
        lex.last_accepting_character_position = lex.current_run_character_position;
      }
      while (lex.table_dict.check[lex.table_dict.base[tmp_lexer_current_state] + counter] !== tmp_lexer_current_state) {
        tmp_lexer_current_state = lex.table_dict.def[tmp_lexer_current_state];
        if (tmp_lexer_current_state >= 33) {
          counter = lex.table_dict.meta[counter];
        }
      }
      tmp_lexer_current_state = lex.table_dict.nxt[lex.table_dict.base[tmp_lexer_current_state] + counter];
    }
    return tmp_lexer_current_state;
  };

  // (YY_NEW_FILE) Special action meaning "start processing a new file".
  lex.startProcessingNewFile = function () {
    lex.restartLex(lex.file_input || YY.file_in);
  };

  // (yyrestart) - cutting corners, initBuffer is is called inside createBuffer
  lex.restartLex = function (my_input_file) {
    lex.current_buffer = lex.createBuffer(my_input_file, lex.default_buffer_size);
    lex.loadBufferState();
  };

  // (yy_get_next_buffer) - try to read in a new buffer (or block??)
  //  Returns a code representing an action:
  //   end_of_block_action_last_match (2) = goto? last match
  //   end_of_block_action_continue_scan (0) = continue scanning from current position
  //   end_of_block_action_end_of_file (1) = end of file
  lex.getNextBuffer = function () {
    var current_buffer_view = lex.current_buffer.buffer_state_array_buffer,
      current_buffer_len = current_buffer_view.byteLength,
      content_pointer = lex.matched_string_pseudo_pointer,
      current_buffer_offset,
      number_to_move,
      number_to_read,
      return_value,
      new_size,
      i;

    if (lex.current_run_buffer_character_position > lex.current_buffer.buffer_state_array_buffer.getInt8(lex.current_buffer.buffer_state_character_len + 1)) {
      throw new Error("[Error] - Fatal flex scanner internal error - end of buffer missed");
    }

    // Don't try to fill the buffer, so this is an EOF (end of file).
    if (lex.current_buffer.buffer_state_fill_if_full === 0) {

      // We matched a single character, the EOB, so treat this as a final EOF.
      if (lex.current_run_buffer_character_position - lex.matched_string_pseudo_pointer - lex.more_adjust === 1) {
        return lex.end_of_block_action_end_of_file;
      }

      // We matched some text prior to the EOB, first process it.
      return lex.end_of_block_action_last_match;
    }

    // Try to read more data.
    // First move last chars to start of buffer.
    // //XXX *(dest++) = *(source++); totally not sure
    number_to_move = (lex.current_run_buffer_character_position - lex.matched_string_pseudo_pointer) - 1;
    for (i = 0; i < number_to_move; i++) {
      current_buffer_view.setInt8(current_buffer_len++, content_pointer++);
    }

    // don't read, it's not guaranteed to return an EOF, just force an EOF
    if (lex.current_buffer.buffer_status === lex.buffer_eof_pending) {
      lex.current_buffer.buffer_state_character_len = lex.buffer_character_len = 0;
    } else {
      number_to_read = lex.current_buffer.buffer_state_size - number_to_move - 1;

      // Not enough room in the buffer - grow it, sigh....
      while (number_to_read <= 0) {

        // memory mongering
        if (lex.uses_reject) {
          throw new Error("[error] - input buffer overflow, can't enlarge buffer because scanner uses REJECT");
        } else {
          
          // not sure I can use len here, but can't subtract the DataView
          current_buffer_offset = lex.current_run_buffer_character_position - current_buffer_len;
          if (lex.current_buffer.buffer_is_ours) {
            new_size = lex.current_buffer.buffer_state_size * 2;

            if (new_size <= 0) {
              lex.current_buffer.buffer_state_size += lex.current_buffer.buffer_state_size / 8;
            } else {
              lex.current_buffer.buffer_state_size = 2;
            }

            // Include room in for 2 EOB chars (careful, we use ACTUAL here,
            // not the array_buffer which is the data view to actual)
            lex.growCurrentBuffer(lex.current_buffer.buffer_state_size + 2);
          } else {
            
            // Can't grow it, we don't own it.
            lex.current_buffer.buffer_state_array_buffer = 0;
          }
          if (lex.current_buffer.buffer_state_array_buffer === 0) {
            throw new Error("[error] - fatal error, scanner input buffer overflow");
          }
          // XXX ditch the above
          lex.current_run_buffer_character_position = lex.current_buffer.buffer_state_array_buffer.getInt8(current_buffer_offset);
          number_to_read = lex.current_buffer.buffer_state_size - number_to_move - 1;
        }

        if (number_to_read > lex.buffer_read_chunk_size) {
          number_to_read = lex.buffer_read_chunk_size;
        }

        // Read in more data.
        // We have to pass in the correct position on the buffer, this should 
        // return buffer_character_len or at least set it
        lex.readChunkFromInput((lex.current_buffer.buffer_state_array_buffer.getInt8(number_to_move)), lex.buffer_character_len, number_to_read);
        lex.current_buffer.buffer_state_character_len = lex.buffer_character_len;
      }
    
      if (lex.buffer_character_len === 0) {
        if (number_to_move === lex.more_adjust) {
          return_value = lex.end_of_block_action_end_of_file;
          lex.restartLex(lex.file_input);
        } else {
          return_value = lex.end_of_block_action_last_match;
          lex.current_buffer.buffer_status = lex.buffer_eof_pending;
        }
      } else {
        return_value = lex.end_of_block_action_continue_scan;
      }

      lex.buffer_character_len += number_to_move;
      lex.current_buffer.buffer_state_array_buffer.setInt8(lex.current_buffer.buffer_state_character_len, lex.buffer_end_character);
      lex.current_buffer.buffer_state_array_buffer.setInt8(lex.current_buffer.buffer_state_character_len + 1, lex.buffer_end_character);
      lex.matched_string_pseudo_pointer = lex.current_buffer.buffer_state_array_buffer.getInt8(0);
      return return_value;
    }
  };
  

  // (YY_DO_BEFORE_ACTION) Done after the current pattern has been matched and 
  // before the corresponding action - sets up lex.matched_string (yytext).
  lex.doBeforeAction = function () {
    lex.matched_string_pseudo_pointer = lex.current_run_buffer_start_position;
    lex.matched_string_len = lex.current_run_character_position - lex.current_run_buffer_start_position;
    lex.tmp_character_hold = lex.current_run_character_position; // pointer to
    lex.current_run_buffer_character_position = lex.current_run_character_position;
  };

  // (GOTO yy_find_action)
  lex.findAction = function () {

    // (yy_act) int only used within lexer
    lex.action_to_run = lex.table_dict.accept[lex.current_state];
        
    // have to back up
    if (lex.action_to_run === 0) {
      lex.current_run_character_position = lex.last_accepting_character_position;
      lex.current_state = lex.last_accepting_state;
      lex.action_to_run = lex.table_dict.accept[lex.current_state];
    }
    lex.doBeforeAction();
  };

  // (GOTO yy_do_action)
  // also called to access EOF actions.
  lex.doAction = function () {
    switch (lex.action_to_run) {

      case 0:
        // must back up, undo the effects of lex.doBeforeAction
        //XXX what? *lex.current_run_character_position = lex.tmp_character_hold;
        lex.current_run_character_position = lex.last_accepting_character_position;
        lex.current_state = lex.last_accepting_state;
        return lex.findAction();
      case 1: // #line 2 "gram.l"
        lex.ruleSetup();
        //{
        YY.scope.match_string = lex.matched_string + 1;
        return("TAG");
        //}
      case 2: //#line 7 "gram.l"
        lex.ruleSetup();
        //{
        YY.scope.match_string = lex.matched_string;
        return "SYMBOL";
        //}
      case 3: //#line 12 "gram.l"
        lex.ruleSetup();
        //{
        YY.custom_dict.is_block_start_or_end = 1;
        return("OPEN");
        //}
      case 4: //#line 17 "gram.l"
        lex.ruleSetup();
        //{
        YY.custom_dict.is_block_start_or_end = 0;
        return("CLOSE");
        //}
      case 5: //#line 22 "gram.l"
        lex.ruleSetup();
        return("CTRL_ASSIGN");
      case 6: //#line 23 "gram.l"
        lex.ruleSetup();
        return("CTRL_IGNORE");
      case 7: //#line 24 "gram.l"
        lex.ruleSetup();
        return("REVERSE");
      case 8: //#line 25 "gram.l"
        lex.ruleSetup();
        return("STARTCLASS");
      case 9: //#line 26 "gram.l"
        lex.ruleSetup();
        return("LET");
      case 10: //#line 27 "gram.l"
        lex.ruleSetup();
        return("NL");
      case 11: //#line 28 "gram.l"
        lex.ruleSetup();
        return("REMARK");
      case 12: //#line 29 "gram.l"
        lex.ruleSetup();
        //{
        return;
        //};
      case 13: //#line 31 "gram.l"
        lex.ruleSetup();
        //{
        throw new Error("Lexical mistake: " + lex.matched_string);
        //return 1;
        //}
      case 14: //#line 35 "gram.l"
        lex.ruleSetup();
        lex.echo();
        break;
      case lex.setEofState(lex.initial): //#line 723 "lex.yy.c" ~ 15 + 1 + state
        return lex.terminate();
      case lex.buffer_end: // 15

        // Amount of text matched not including the EOB char.
        lex.amount_of_matched_text = (lex.current_run_character_position - lex.matched_string_pseudo_pointer) - 1;
  
        // Undo the effects of lex.doBeforeAction.
        lex.current_run_character_position = lex.tmp_character_hold;
        lex.restoreOriginalOffset();

        if (lex.current_buffer.buffer_status === lex.buffer_is_new) {
  
          // We're scanning a new file or input source.  It's possible that 
          // this happened because the user just pointed file input (yyin) at 
          // a new source and called yylex().  If so, then we have to assure
          // consistency between lex.current_buffer and our
          // globals.  Here is the right place to do so, because this is the 
          // first action (other than possibly a back-up) that will match for 
          // the new input source.
          lex.buffer_character_len = lex.current_buffer.buffer_state_character_len;
          lex.current_buffer.buffer_state_input_file = lex.file_input;
          lex.current_buffer.buffer_status = lex.buffer_is_normal;
        }
  
        // Note that here we test for lex.current_run_buffer_character_position 
        // "<=" to the position of the first EOB (end of block!) in the buffer, 
        // since lex.current_run_buffer_character_position will already have been 
        // incremented past the NUL character (since all states make 
        // transitions on EOB to the end-of-buffer state).  Contrast this with 
        // the test in input().
            
        // XXX check getInt8 is correct ...len
        if (lex.current_run_buffer_character_position <= lex.current_buffer.buffer_state_array_buffer.getInt8(lex.current_buffer.buffer_state_character_len)) {

          // This was really a NUL.
          lex.current_run_buffer_character_position = lex.matched_string_pseudo_pointer + lex.amount_of_matched_text;
          lex.current_state = lex.getPreviousState();

          // Okay, we're now positioned to make the NUL transition.  We couldn't
          // have lex.getPreviousState() go ahead and do it for us because it 
          // doesn't know how to deal with the possibility of jamming (and we 
          // don't want to build jamming into it because then it will run more 
          // slowly).
          lex.next_state = lex.attemptNulTransition(lex.current_state);
          lex.current_run_buffer_start_position = lex.matched_string_pseudo_pointer + lex.more_adjust;
  
          // Consume the NUL.
          if (lex.next_state) {
            lex.current_run_character_position = ++lex.current_run_buffer_character_position;
            lex.current_state = lex.next_state;
            lex.matchText();
          } else {
            lex.current_run_character_position = lex.current_run_buffer_character_position;
            lex.findAction();
          }
        } else {

          // reading in input file handling
          switch (lex.getNextBuffer()) {
            case lex.end_of_block_action_end_of_file:
              lex.buffer_switched_on_end_of_file = 0;
              if (lex.thatsAWrap()) {

                // Note: because we've taken care in getNextBuffer() to have 
                // set up matched_string (yytext), we can now set up
                // current_run_buffer_character_position so that if some total
                // hoser (like flex itself) wants to call the scanner after we 
                // return the nullinger, it'll still work - another nullinger 
                // will get returned.
                lex.current_run_buffer_character_position = lex.matched_string_pseudo_pointer + lex.more_adjust;
                lex.action_to_run = lex.setEofState(lex.start_state_confusulation);
                lex.doAction();
              } else {

                // infinity?
                if (lex.buffer_switched_on_end_of_file === 0) {
                  lex.startProcessingNewFile();
                }
              }
              break;
            case lex.end_of_block_action_continue_scan:
              lex.current_run_buffer_character_position = lex.matched_string_pseudo_pointer + lex.amount_of_matched_text;
              lex.current_state = lex.getPreviousState();
        
              lex.current_run_character_position = lex.current_run_buffer_character_position;
              lex.current_run_buffer_start_position = lex.matched_string_pseudo_pointer + lex.more_adjust;
              lex.matchText();
              break;
            case lex.end_of_block_action_last_match:

              // XXX this return the character, not the buffer?
              lex.current_run_buffer_character_position = lex.current_buffer.buffer_state_array_buffer.getInt8(lex.current_buffer.buffer_state_character_len);
              lex.current_state = lex.getPreviousState();
              lex.current_run_character_position = lex.current_run_buffer_character_position;
              lex.current_run_buffer_start_position = lex.matched_string_pseudo_pointer + lex.more_adjust;
              lex.findAction();
              break;
          }
        }
        break; // end buffer
      default:
        throw new Error("[error] - Fatal flex scanner internal error - no action found");
      } // end of action switch
  };
  
  // ------------------------------- Start -------------------------------------
  // Default declaration of scanner
  lex.lexer = function (my_ival, my_loco, my_param) {
    if (lex.init) {
      lex.init = 0;

      // first start state is 1
      lex.start_state = 1;
      
      // set input
      lex.file_input = YY.file_in || 0;

      // set output
      lex.file_output = YY.file_out || 0;
  
      if (lex.current_buffer === undefined) {
        lex.current_buffer = lex.createBuffer(lex.file_input, lex.default_buffer_size);
      }
      lex.loadBufferState();
    }

    // loop until end of file is reached
    while (1) {
      lex.current_run_character_position = lex.current_run_buffer_character_position;

      // Support of yytext.
      lex.current_run_character_position = lex.tmp_character_hold;

      // yy_bp points to the position in yy_ch_buf of the start of current run.
      // start position = character poistion
      lex.current_run_buffer_start_position = lex.current_run_character_position;

      lexer_current_state = lex.start_state;

      // as functions should not be declared inside a loop
      lex.matchText();
      lex.findAction();
      lex.doAction();
    } // end of scanning one token
  };

  // ------------------------- Stuff not called --------------------------------
  // remove if not used, weird stuff included, not fixed up

  // (BEGIN)
  // Enter a start condition.  This macro really ought to take a parameter,
  // but we do it the disgusting crufty way forced on us by the ()-less
  // definition of BEGIN.
  // XXX #define BEGIN lex.start_state = 1 + 2 *
  // XXX calls always pass a state, to do ?
  lex.xxx_begin = function (my_state) {
    lex.start_state = 1 + 2;
  };

  // (YY_NUM_RULES)
  lex.xxx_number_of_rules = 14;

  // (yyleng)
  // externals => http://epaperpress.com/lexandyacc/prl.html
  // this should be passed in echo, no?
  lex.xxx_leng;
  
  // (EOF)
  lex.xxx_eof = -1;

  // (yy_size_t)
  // The following is because we cannot portably get our hands on size_t
  // (without autoconf's help, which isn't available because we want
  // flex-generated scanners to compile on their own).
  lex.xxx_size;

  // (yyless)
  // The funky do-while in the following #define is used to turn the definition
  // int a single C statement (which needs a semi-colon terminator).  This
  // avoids problems with code like:
  //
  //  if ( condition_holds )
  //    yyless( 5 );
  //  else
  //    do_something_else();
  //
  // Prior to using the do-while the compiler would get upset at the
  // "else" because it interpreted the "if" statement as being all
  // done when it reached the ';' after the yyless() call.
  // XXX Used elsewhere
  // Return all but the first 'n' matched characters back to the input stream.
  lex.xxx_less = function (my_n) {

    // Undo effects of setting up lex.matched_string (yytext).
    lex.current_run_buffer_start_position = lex.tmp_character_hold;
    lex.restoreOriginalOffset();
    lex.current_run_buffer_character_position = lex.current_run_character_position = lex.current_run_buffer_start_position + my_n - lex.more_adjust;
    lex.doBeforeAction(); // set up lex.matched_string (yytext) again
  };
  
  // (yyless)
  // Redefine yyless() so it works in section 3 code.
  // XXX who's bad? what is section 3?
  lex.xxx_less = function (my_n) {

    // Undo effects of setting up yytext.
    lex.matched_string[lex.matched_string_len] = lex.tmp_character_hold;
    lex.current_run_buffer_character_position = lex.matched_string + my_n;
    lex.tmp_character_hold = lex.current_run_buffer_character_position;
    lex.current_run_buffer_character_position = '\0';
    lex.matched_string_len = my_n;
  };

  // (unput)
  // yyunput = function (c, lex.current_run_buffer_start_position) {
  lex.xxx_unput = function (my_c, my_matched_string_pseudo_pointer) {
    var number_to_move,
      dest,
      source;

    lex.current_run_character_position = lex.current_run_buffer_character_position;

    // undo effects of setting up lex.matched_string (yytext)
    lex.current_run_character_position = lex.tmp_character_hold;

    // need to shift things up to make room
    if (lex.current_run_character_position < lex.current_buffer.buffer_state_array_buffer + 2) { 

      // +2 for EOB chars.
      number_to_move = lex.buffer_character_len + 2;
      dest = lex.current_buffer.buffer_state_array_buffer.getInt8(lex.current_buffer.buffer_state_size + 2);
      source = lex.current_buffer.buffer_state_array_buffer.getInt8(number_to_move);
      while (source > lex.current_buffer.buffer_state_array_buffer) {
        //XXX*--dest = *--source;
      }
      lex.current_run_character_position += (dest - source);
      lex.current_run_buffer_start_position += (dest - source);
      lex.current_buffer.buffer_state_character_len = lex.buffer_character_len = lex.current_buffer.buffer_state_size;
      if (lex.current_run_character_position < lex.current_buffer.buffer_state_array_buffer + 2 ) {
        throw new Error("[error] - Flex scanner push-back overflow");
      }
    }
    // XXX? *--lex.current_run_character_position = (char) c;
    lex.current_run_character_position = my_c;
    lex.matched_string_pseudo_pointer = lex.current_run_buffer_start_position;
    lex.tmp_character_hold = lex.current_run_character_position;
    lex.current_run_buffer_character_position = lex.current_run_character_position;
  };

  // (input)
  lex.xxx_input = function() {
    var character,
      offset;

    lex.current_run_buffer_character_position = lex.tmp_character_hold;

    // lex.current_run_buffer_character_position now points to the character we 
    // want to return. If this occurs *before* the EOB characters, then it's a
    // valid NUL; if not, then we've hit the end of the buffer.
    if (lex.current_run_buffer_character_position === lex.buffer_end_character) {
    
      // This was really a NUL.
      if (lex.current_run_buffer_character_position < lex.current_buffer.buffer_state_array_buffer.getInt8(lex.current_buffer.buffer_state_character_len)) {
        lex.current_run_buffer_character_position = '\0';

      // need more input
      } else {
        offset = lex.current_run_buffer_character_position - lex.matched_string_pseudo_pointer;
        lex.current_run_buffer_character_position++;

        switch (lex.getNextBuffer()) {

          // This happens because yy_g_n_b() sees that we've accumulated a
          // token and flags that we need to try matching the token before
          // proceeding. But for input(), there's no matching to consider.
          // So convert the lex.end_of_block_action_last_match
          // to end_of_block_action_end_of_file.
          case lex.end_of_block_action_last_match:
          
            // Reset buffer status.
            return lex.restartLex(lex.file_input);
  
          //fall through
          case lex.end_of_block_action_end_of_file:
            if (lex.thatsAWrap()) {
              return lex.xxx_eof;
            }
            if (lex.buffer_switched_on_end_of_file === 0) {
              lex.startProcessingNewFile();
              return input();
            }
            break;

          case lex.end_of_block_action_continue_scan:
            lex.current_run_buffer_character_position = lex.matched_string_pseudo_pointer + offset;
            break;
        }
      }
    }

    // cast for 8-bit char's
    character = lex.current_run_buffer_character_position;

    // preserve lex.matched_string (yytext) 
    lex.current_run_buffer_character_position = '\0';  
    lex.tmp_character_hold = ++lex.current_run_buffer_character_position;
    return character;
  };

  // (yy_set_bol)
  // set beginning of line ^ to be active
  lex.xxx_set_bol = function (my_at_bol) {
    if (!lex.current_buffer) {
      lex.current_buffer = lex.createBuffer(lex.file_input, lex.default_buffer_size);
      lex.current_buffer.input_line_start = my_at_bol;
    }
  };

  // (YY_AT_BOL) - duplicate?
  lex.xxx_is_at_bol = function () {
    return lex.current_buffer.input_line_start;
  };
  
  // (yy_flex_free)
  lex.xxx_freeBuffer = function (my_buffer) {
    my_buffer = null;
  };

  // (yy_switch_to_buffer)
  lex.xxx_switchToBuffer = function (my_buffer) {
    if (lex.current_buffer === my_buffer) {
      return;
    }

    // Flush out information for old buffer.
    if (lex.current_buffer) {
      lex.current_run_buffer_character_position = lex.tmp_character_hold;
      lex.current_buffer.buffer_state_current_position = lex.current_run_buffer_character_position;
      lex.current_buffer.buffer_state_character_len = lex.buffer_character_len;
    }
    lex.current_buffer = my_buffer;
    lex.loadBufferState();

    // We don't actually know whether we did this switch during
    // EOF (lex.thatsAWrap) processing, but the only time this flag
    // is looked at is after lex.thatsAWrap() is called, so it's safe
    // to go ahead and always set it.
    lex.buffer_switched_on_end_of_file = 1;
  };

  // (yy_delete_buffer)
  lex.xxx_deleteBuffer = function (my_buffer) {
    if (my_buffer === undefined) {
      return;
    }
    if (my_buffer === lex.current_buffer) {
      lex.current_buffer = 0;
    }
    if (my_buffer.buffer_is_ours) {
      lex.freeBuffer(my_buffer.buffer_state_array_buffer);
    }
    lex.freeBuffer(my_buffer);
  };

  // (yy_flush_buffer)
  lex.xxx_flushBuffer = function (my_buffer) {
    if (my_buffer === undefined) {
      return;
    }

    my_buffer.buffer_state_character_len = 0;

    // We always need two end-of-buffer characters. The first causes
    // a transition to the end-of-buffer state. The second causes
    // a jam in that state.
    my_buffer.buffer_state_array_buffer.setInt8(0, lex.buffer_end_character);
    my_buffer.buffer_state_array_buffer.setInt8(1, lex.buffer_end_character);

    my_buffer.buffer_state_current_position = my_buffer.buffer_state_array_buffer.getInt8(0);
  
    my_buffer.input_line_start = 1;
    my_buffer.buffer_status = lex.buffer_is_new;
  
    if (my_buffer === lex.current_buffer) {
      lex.loadBufferState();
    }
  };

  // (yy_scan_buffer)
  lex.xxx_scanBuffer = function (my_base, my_size) {
    var buffer;

    // They forgot to leave room for the EOB's.
    if (my_size < 2 || my_base.getInt8(my_size - 2) !== lex.buffer_end_character || my_base.getInt8(my_size - 1) !== lex.buffer_end_character) {
      return 0;
    }

    buffer = lex.setBuffer(sizeof(yy_buffer_state));
    if (buffer === undefined) {
      throw new Error("[error] out of dynamic memory in scanBuffer()");
    }
    buffer.buffer_state_size = my_size - 2;  // "- 2" to take care of EOB's/
    buffer.buffer_state_current_position = b.buffer_state_array_buffer = my_base;
    buffer.buffer_is_ours = 0;
    buffer.buffer_state_input_file = 0;
    buffer.buffer_character_len = b.buffer_state_size;
    buffer.buffer_state_interactive_input = 0;
    buffer.input_line_start = 1;
    buffer.buffer_state_fill_if_full = 0;
    buffer.buffer_status = lex.buffer_is_new;
    lex.switchToBuffer(buffer);
    return buffer; 
  };

  // (YY_STACK_USED) stacks
  lex.xxx_stack_used = 0;
  
  if (lex.stack_used) {

    // (YY_START_STACK_INCR)
    // Number of entries by which start-condition stack grows.
    lex.xxx_start_stack_increment = 25;

    // (YY_NO_PUSH_STATE)
    lex.xxx_no_push_state = 0;
    
    // (YY_NO_POP_STATE)
    lex.xxx_no_pop_state = 0;

    // (YY_NO_TOP_STATE)
    lex.xxx_no_top_state = 0; 

    // (yy_start_stack_ptr)
    lex.xxx_start_stack_pointer = 0;

    // (yy_start_stack_depth)
    lex.xxx_start_stack_depth = 0;

    // (yy_start_stack)
    lex.xxx_start_stack = 0;

  } else {

    // (YY_NO_PUSH_STATE)
    lex.xxx_no_push_state = 1;
    
    // (YY_NO_POP_STATE)
    lex.xxx_no_pop_state = 1;

    // (YY_NO_TOP_STATE)
    lex.xxx_no_top_state = 1;
  }

  // (yy_push_state)
  if (lex.no_push_state === 0) {
    lex.xxx_pushState = function (my_new_state) {
      var new_size;
      if (lex.start_stack_pointer >= lex.start_stack_depth) {
        lex.start_stack_depth += lex.start_stack_increment;
        // XXX sizeof
        new_size = lex.start_stack_depth * sizeof(int);

        if (lex.start_stack === 0) {
          lex.start_stack = lex.setBuffer(new_size);
        } else {
          lex.start_stack = lex.growCurrentBuffer(lex.start_stack, new_size);
        }
        if (lex.start_stack === undefined) {
          throw new Error("[error] - Out of memory expanding start-condition stack");
        }
      }
      lex.start_stack[lex.start_stack_pointer++] = lex.start_state_confusulation;
      lex.begin(new_state);
    };
  }

  // (yy_pop_state)
  if (lex.no_pop_state === 0) {
    lex.xxx_popState = function () {
      if (--lex.start_stack_pointer < 0) {
        throw new Error("[error] - start-condition stack underflow" );
      }
      lex.begin(lex.start_stack[lex.start_stack_pointer]);
    };
  }

  // (yy_top_state)
  if (lex.no_top_state === 0) {
    lex.xxx_topState = function () {
      return lex.start_stack[lex.start_stack_pointer - 1];
    };
  }

  // (yy_scan_string) 
  lex.xxx_scanString = function (my_string) {
    var len;
      for (len = 0; my_string[len]; ++len) {
        ;
      }
      return lex.scanBytes(my_string, len);
  };

  // (yy_scan_bytes)
  lex.xxx_scanBytes = function (my_bytes, my_len) {
    var buffer,
      scanned_buffer,
      i,
      n;

    // Get memory for full buffer, including space for trailing EOB's.
    n = len + 2;
    buffer = lex.setBuffer(n);
    if (buffer === undefined) {
      throw new Error("[[error] - out of dynamic memory in scanBytes()");
    }
    for (i = 0; i < len; ++i) {
      buffer.setInt8(i, bytes.charCodeAt(i));
    }
    buffer.setInt8(len, lex.buffer_end_character);
    buffer.setInt8(len + 1, lex.buffer_end_character);
    
    scanned_buffer = lex.scanBuffer(buffer, n);
    if (scanned_buffer === undefined) {
      throw new Error("[error] - bad buffer in scanBytes()" );
    }
    
    // It's okay to grow etc. this buffer, and we should throw it
    // away when we're done.
    scanned_buffer.buffer_is_ours = 1;

    return scanned_buffer;
  };

  window.lexer = lex.lexer;

} (window, YY));

